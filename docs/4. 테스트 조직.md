# 4. 테스트 조직
- 테스트 코드를 잘 조직하고 구조화할 수 있는 JUnit 기능 위주..

## 4.1 AAA로 테스트 일관성 유지
- 테스트 코드를 가시적으로 **준비, 실행, 단언(Arrange, Act, Assert)** 부분으로 조직 -> triple-A(AAA)
- given, when, then이랑 비슷하다고 보면 될 것 같음.

### Arrange, Act, Assert
- Arrange: 테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인
- Act: 테스트 코드 실행
- Assert: 실행한 코드가 기대한 대로 동작하는 지 확인

> 경우에 따라서 After 과정이 있음: 테스트 코드에서 자원을 할당하는 로직이 있었다면 clean up 되었는지 확인

## 4.2 동작 테스트 vs 메서드 테스트
- 개별 메서드를 테스트한다는 생각보다 클래스의 종합적인 동작에 집중해야 한다.

## 4.3 테스트와 프로덕션 코드의 관계
- 당연히 테스트 코드가 프로덕션 코드에 의존하는 관계이지, 그 반대는 말이 안 됨.
- 더 많은 단위 테스트를 작성할수록 설계를 변경했을 시 테스트 작성이 훨씬 용이해지는 경우가 늘어난다.
- 테스트 친화적인 설계를 채택할수록 편해지고, 설계 자체도 더 좋아진다.

### 4.3.1 테스트와 프로덕션 코드 분리
- 테스트를 별도 디렉터리로 분리하지만 프로덕션 코드와 같은 패키지에 넣기 (현재도 그렇게 하고 있음)

### 4.3.2 내부 데이터 노출 vs 내부 동작 노출
- 비공개 코드를 호출하는 테스트는 그 자체로 구현 세부 사항과 결속하게 된다.
  - 이 경우 세부 사항이 변경되면 기술적으로 공개적인 행동(인터페이스)이 그대로라고 해도 테스트는 깨질 수 있다.
- 코드의 작은 변화가 수많은 테스트를 깨면 프로그래머는 리팩토링을 꺼리게 되고, 코드 베이스는 퇴화한다.
- 종종 테스트를 작성하려고 객체에 대해 과도하게 사적인 질문을 하게 될 수도 있다.
- **테스트를 위해 내부 데이터를 노출하는 것은 테스트와 프로덕션 코드 사이에 과도한 결합을 초래한다.**
- 복잡한 private 메서드를 테스트하고 싶어질 수 있다.
  - **내부 행위를 테스트하려는 충동이 든다면 설계에 문제가 있는 것이다!**
  - **이 문제는 대부분 SRP를 지키기 않아서 그렇다!**
  - **가장 좋은 해결책은 흥미로운 private 메서드를 추출하여 다른 클래스로 이동하는 것이다.**
# 13. 까다로운 테스트

- 멀티스레드 코드 테스트
- 데이터베이스 코드 테스트
- 마치며

> 여기서 스레드와 영속성을 테스트하는 접근 방법은 2가지 주제에 기반을 둔다.
> 
> 더 좋은 테스트 지원을 위한 '설계 다시 하기', 'stub과 mock을 사용해 의존성 끊기'

## 13.1 멀티스레드 코드 테스트
- 동시성 처리가 필요한 애플리케이션 코드를 테스트하는 것은 기술적으로 단위 테스트가 아닌 통합 테스트 영역이다.
- 멀티스레드 코드를 테스트하는 예제를 통해 방법을 익혀보자

### 13.1.1 단순하고 똑똑하게 유지
- **스레드 통제와 애플리케이션 코드 사이의 중첩을 최소화해라**
  - 스레드 없이 다량의 애플리케이션 코드를 단위 테스트할 수 있도록 설계를 변경해라
  - 남은 작은 코드에 대해 스레드에 집중적인 테스트를 해라
- **다른 사람의 작업을 믿어라**
  - 너무 자바의 내용이라 패스
  - (다른 사람들이 잘 만들어놓은 util 클래스 사용하라는 얘기, BlockingQueue)

### 13.1.2 모든 매칭 찾기
- 관련 있는 모든 프로파일을 수집하는 ProfileMatcher 클래스 예시
- (12장의 코드에서 많은 변화가 있는 것 같음)

```kotlin
import java.util.concurrent.Executors
import java.util.stream.Collectors


class ProfileMatcher {
   private val profiles: MutableMap<String, Profile> = HashMap()
   fun add(profile: Profile) {
      profiles[profile.getId()] = profile
   }

   fun findMatchingProfiles(
      criteria: Criteria?, listener: MatchListener
   ) {
      val executor = Executors.newFixedThreadPool(DEFAULT_POOL_SIZE)
      val matchSets = profiles.values.stream()
         .map { profile: Profile ->
            profile.getMatchSet(criteria)
         }
         .collect(Collectors.toList())
      for (set in matchSets) {
         val runnable = Runnable {
           if (set.matches())
               listener.foundMatch(profiles[set.profileId], set)
         }
         executor.execute(runnable)
      }
      executor.shutdown()
   }

   companion object {
      private const val DEFAULT_POOL_SIZE = 4
   }
}
```

- 각 프로파일에 대해 MatchSet 인스턴스를 모으는 findMatchingProfiles()
- 각 MatchSet에 대해 메서드는 별도의 스레드를 생성해 MatchSet 객체의 matches() return 값이 true이면 프로파일과 그에 맞는 MatchSet 객체를 listener로 보낸다.

### 13.1.3 애플리케이션 로직 추출
- findMatchingProfiles() 분리
- 분리한 collectMatchSets 테스트 작성